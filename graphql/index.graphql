"Blockchain data scalar type"
scalar BlockchainData

"Broadcast scalar id type"
scalar BroadcastId

"ChainId custom scalar type"
scalar ChainId

"collect module data scalar type"
scalar CollectModuleData

"Contract address custom scalar type"
scalar ContractAddress

"create handle custom scalar type"
scalar CreateHandle

"Cursor custom scalar type"
scalar Cursor

"Ethereum address custom scalar type"
scalar EthereumAddress

"follow module data scalar type"
scalar FollowModuleData

"handle custom scalar type"
scalar Handle

"handle claim id custom scalar type"
scalar HandleClaimIdScalar

"Internal publication id custom scalar type"
scalar InternalPublicationId

"jwt custom scalar type"
scalar Jwt

"limit custom scalar type"
scalar LimitScalar

"Markdown scalar type"
scalar Markdown

"mimetype custom scalar type"
scalar MimeType

"Nft ownership id type"
scalar NftOwnershipId

"Nonce custom scalar type"
scalar Nonce

"ProfileId custom scalar type"
scalar ProfileId

"Publication id custom scalar type"
scalar PublicationId

"Publication url scalar type"
scalar PublicationUrl

"reference module data scalar type"
scalar ReferenceModuleData

"Query search"
scalar Search

"Relayer signature"
scalar Signature

"Sources custom scalar type"
scalar Sources

"timestamp date custom scalar type"
scalar TimestampScalar

"The tx hash"
scalar TxHash

"The tx id"
scalar TxId

"UnixTimestamp custom scalar type"
scalar UnixTimestamp

"Url scalar type"
scalar Url

"Represents NULL values"
scalar Void

union CollectModule = FreeCollectModuleSettings | FeeCollectModuleSettings | LimitedFeeCollectModuleSettings | LimitedTimedFeeCollectModuleSettings | RevertCollectModuleSettings | TimedFeeCollectModuleSettings

union FollowModule = FeeFollowModuleSettings | ProfileFollowModuleSettings | RevertFollowModuleSettings

union MainPostReference = Post | Mirror

union MentionPublication = Post | Comment

union MirrorablePublication = Post | Comment

union Notification = NewFollowerNotification | NewCollectNotification | NewCommentNotification | NewMirrorNotification | NewMentionNotification

union ProfileMedia = NftImage | MediaSet

union Publication = Post | Comment | Mirror

union PublicationForSale = Post | Comment

union PublicationSearchResultItem = Post | Comment

union ReferenceModule = FollowOnlyReferenceModuleSettings

union RelayResult = RelayerResult | RelayError

union SearchResult = PublicationSearchResult | ProfileSearchResult

union TransactionResult = TransactionIndexedResult | TransactionError

enum CollectModules {
  LimitedFeeCollectModule
  FeeCollectModule
  LimitedTimedFeeCollectModule
  TimedFeeCollectModule
  RevertCollectModule
  FreeCollectModule
}

enum FollowModules {
  FeeFollowModule
  RevertFollowModule
  ProfileFollowModule
}

enum MetadataDisplayType {
  number
  string
  date
}

enum ProfileRevenueTypes {
  POST
  COMMENT
  MIRROR
}

enum ProfileSortCriteria {
  CREATED_ON
  MOST_FOLLOWERS
  LATEST_CREATED
  MOST_POSTS
  MOST_COMMENTS
  MOST_MIRRORS
  MOST_PUBLICATION
  MOST_COLLECTS
}

enum PublicationMetadataStatusType {
  PENDING
  METADATA_VALIDATION_FAILED
  SUCCESS
}

enum PublicationReportingFraudSubreason {
  SCAM
  IMPERSONATION
}

enum PublicationReportingIllegalSubreason {
  ANIMAL_ABUSE
  HUMAN_ABUSE
}

enum PublicationReportingReason {
  SENSITIVE
  ILLEGAL
  FRAUD
}

enum PublicationReportingSensitiveSubreason {
  NSFW
  OFFENSIVE
}

enum PublicationSortCriteria {
  TOP_COMMENTED
  TOP_COLLECTED
  TOP_MIRRORED
  LATEST
}

enum PublicationTypes {
  POST
  COMMENT
  MIRROR
}

enum ReactionTypes {
  UPVOTE
  DOWNVOTE
}

enum ReferenceModules {
  FollowerOnlyReferenceModule
}

enum RelayErrorReasons {
  REJECTED
  HANDLE_TAKEN
  EXPIRED
  WRONG_WALLET_SIGNED
  NOT_ALLOWED
}

enum SearchRequestTypes {
  PUBLICATION
  PROFILE
}

enum TimelineType {
  POST
  COMMENT
  MIRROR
  COLLECT_POST
  COLLECT_COMMENT
}

enum TransactionErrorReasons {
  REVERTED
}

input AchRequest {
  secret: String!
  ethereumAddress: EthereumAddress!
  handle: CreateHandle
  freeTextHandle: Boolean
  overrideTradeMark: Boolean!
}

input ApprovedModuleAllowanceAmountRequest {
  "The contract addresses for the module approved currencies you want to find information on about the user"
  currencies: [ContractAddress!]!
  collectModules: [CollectModules!]!
  followModules: [FollowModules!]!
  referenceModules: [ReferenceModules!]!
}

input BroadcastRequest {
  id: BroadcastId!
  signature: Signature!
}

input BurnProfileRequest {
  profileId: ProfileId!
}

"The challenge request"
input ChallengeRequest {
  "The ethereum address you want to login with"
  address: EthereumAddress!
}

input ClaimHandleRequest {
  id: HandleClaimIdScalar
  freeTextHandle: CreateHandle
  "The follow module"
  followModule: FollowModuleParams
}

input CollectModuleParams {
  "The collect empty collect module"
  freeCollectModule: FreeCollectModuleParams
  "The collect revert collect module"
  revertCollectModule: Boolean
  "The collect fee collect module"
  feeCollectModule: FeeCollectModuleParams
  "The collect limited fee collect module"
  limitedFeeCollectModule: LimitedFeeCollectModuleParams
  "The collect limited timed fee collect module"
  limitedTimedFeeCollectModule: LimitedTimedFeeCollectModuleParams
  "The collect timed fee collect module"
  timedFeeCollectModule: TimedFeeCollectModuleParams
}

input CreateCollectRequest {
  publicationId: InternalPublicationId!
}

input CreateMirrorRequest {
  "Profile id"
  profileId: ProfileId!
  "Publication id of what you want to mirror on remember if this is a comment it will be that as the id"
  publicationId: InternalPublicationId!
  "The reference module info"
  referenceModule: ReferenceModuleParams
}

input CreateProfileRequest {
  handle: CreateHandle!
  "The profile picture uri"
  profilePictureUri: Url
  "The follow module"
  followModule: FollowModuleParams
  "The follow NFT URI is the NFT metadata your followers will mint when they follow you. This can be updated at all times. If you do not pass in anything it will create a super cool changing NFT which will show the last publication of your profile as the NFT which looks awesome! This means people do not have to worry about writing this logic but still have the ability to customise it for their followers"
  followNFTURI: Url
}

input CreatePublicCommentRequest {
  "Profile id"
  profileId: ProfileId!
  "Publication id of what your comments on remember if this is a comment you commented on it will be that as the id"
  publicationId: InternalPublicationId!
  "The metadata uploaded somewhere passing in the url to reach it"
  contentURI: Url!
  "The collect module"
  collectModule: CollectModuleParams!
  "The reference module"
  referenceModule: ReferenceModuleParams
}

input CreatePublicPostRequest {
  "Profile id"
  profileId: ProfileId!
  "The metadata uploaded somewhere passing in the url to reach it"
  contentURI: Url!
  "The collect module"
  collectModule: CollectModuleParams!
  "The reference module"
  referenceModule: ReferenceModuleParams
}

input CreatePublicSetProfileMetadataURIRequest {
  "Profile id"
  profileId: ProfileId!
  "The metadata uploaded somewhere passing in the url to reach it"
  metadata: Url!
}

input CreateSetDefaultProfileRequest {
  "Profile id"
  profileId: ProfileId!
}

input CreateSetFollowModuleRequest {
  profileId: ProfileId!
  "The follow module info"
  followModule: FollowModuleParams!
}

input CreateSetFollowNFTUriRequest {
  profileId: ProfileId!
  "The follow NFT URI is the NFT metadata your followers will mint when they follow you. This can be updated at all times. If you do not pass in anything it will create a super cool changing NFT which will show the last publication of your profile as the NFT which looks awesome! This means people do not have to worry about writing this logic but still have the ability to customise it for their followers"
  followNFTURI: Url
}

input CreateToggleFollowRequest {
  profileIds: [ProfileId!]!
  enables: [Boolean!]!
}

input DefaultProfileRequest {
  ethereumAddress: EthereumAddress!
}

input DoesFollow {
  "The follower address remember wallets follow profiles"
  followerAddress: EthereumAddress!
  "The profile id"
  profileId: ProfileId!
}

input DoesFollowRequest {
  "The follower infos"
  followInfos: [DoesFollow!]!
}

input ExploreProfilesRequest {
  limit: LimitScalar
  cursor: Cursor
  timestamp: TimestampScalar
  sortCriteria: ProfileSortCriteria!
}

input ExplorePublicationRequest {
  limit: LimitScalar
  cursor: Cursor
  timestamp: TimestampScalar
  sortCriteria: PublicationSortCriteria!
  "The App Id"
  sources: [Sources!] = []
  "The publication types you want to query"
  publicationTypes: [PublicationTypes!]
  "If you want the randomizer off (default on)"
  noRandomize: Boolean
  "If you wish to exclude any results for profile ids"
  excludeProfileIds: [ProfileId!]
}

input FeeCollectModuleParams {
  "The collect module amount info"
  amount: ModuleFeeAmountParams!
  "The collect module recipient address"
  recipient: EthereumAddress!
  "The collect module referral fee"
  referralFee: Float!
  "Follower only"
  followerOnly: Boolean!
}

input FeeFollowModuleParams {
  "The follow module amount info"
  amount: ModuleFeeAmountParams!
  "The follow module recipient address"
  recipient: EthereumAddress!
}

input FeeFollowModuleRedeemParams {
  "The expected amount to pay"
  amount: ModuleFeeAmountParams!
}

input Follow {
  profile: ProfileId!
  followModule: FollowModuleRedeemParams
}

input FollowModuleParams {
  "The follower fee follower module"
  feeFollowModule: FeeFollowModuleParams
  "The profile follow module"
  profileFollowModule: Boolean
  "The revert follow module"
  revertFollowModule: Boolean
  "The empty follow module"
  freeFollowModule: Boolean
}

input FollowModuleRedeemParams {
  "The follower fee follower module"
  feeFollowModule: FeeFollowModuleRedeemParams
  "The profile follower module"
  profileFollowModule: ProfileFollowModuleRedeemParams
}

input FollowRequest {
  follow: [Follow!]!
}

input FollowerNftOwnedTokenIdsRequest {
  address: EthereumAddress!
  profileId: ProfileId!
}

input FollowersRequest {
  limit: LimitScalar
  cursor: Cursor
  profileId: ProfileId!
}

input FollowingRequest {
  limit: LimitScalar
  cursor: Cursor
  address: EthereumAddress!
}

input FraudReasonInputParams {
  reason: PublicationReportingReason!
  subreason: PublicationReportingFraudSubreason!
}

input FreeCollectModuleParams {
  "Follower only"
  followerOnly: Boolean!
}

input GenerateModuleCurrencyApprovalDataRequest {
  currency: ContractAddress!
  "Floating point number as string (e.g. 42.009837). The server will move its decimal places for you"
  value: String!
  collectModule: CollectModules
  followModule: FollowModules
  referenceModule: ReferenceModules
}

input GlobalProtocolStatsRequest {
  "Unix time from timestamp - if not supplied it will go from 0 timestamp"
  fromTimestamp: UnixTimestamp
  "Unix time to timestamp - if not supplied it go to the present timestamp"
  toTimestamp: UnixTimestamp
  "The App Id"
  sources: [Sources!]
}

input HasCollectedPublicationRequest {
  "Wallet address"
  walletAddress: EthereumAddress!
  "Internal publication ids"
  publicationIds: [InternalPublicationId!]!
}

input HasCollectedRequest {
  collectRequests: [HasCollectedPublicationRequest!]!
}

input HasMirroredProfileRequest {
  "Profile id"
  profileId: ProfileId!
  "Internal publication ids"
  publicationIds: [InternalPublicationId!]!
}

input HasMirroredRequest {
  profilesRequest: [HasMirroredProfileRequest!]!
}

input HasTxHashBeenIndexedRequest {
  "Tx hash.. if your using the broadcaster you should use txId due to gas price upgrades"
  txHash: TxHash
  "Tx id.. if your using the broadcaster you should always use this field"
  txId: TxId
}

input HidePublicationRequest {
  "Publication id"
  publicationId: InternalPublicationId!
}

input IllegalReasonInputParams {
  reason: PublicationReportingReason!
  subreason: PublicationReportingIllegalSubreason!
}

input LimitedFeeCollectModuleParams {
  "The collect module limit"
  collectLimit: String!
  "The collect module amount info"
  amount: ModuleFeeAmountParams!
  "The collect module recipient address"
  recipient: EthereumAddress!
  "The collect module referral fee"
  referralFee: Float!
  "Follower only"
  followerOnly: Boolean!
}

input LimitedTimedFeeCollectModuleParams {
  "The collect module limit"
  collectLimit: String!
  "The collect module amount info"
  amount: ModuleFeeAmountParams!
  "The collect module recipient address"
  recipient: EthereumAddress!
  "The collect module referral fee"
  referralFee: Float!
  "Follower only"
  followerOnly: Boolean!
}

input ModuleFeeAmountParams {
  "The currency address"
  currency: ContractAddress!
  "Floating point number as string (e.g. 42.009837). It could have the entire precision of the Asset or be truncated to the last significant decimal."
  value: String!
}

input NFTData {
  "Id of the nft ownership challenge"
  id: NftOwnershipId!
  "The signature"
  signature: Signature!
}

input NFTsRequest {
  limit: LimitScalar
  cursor: Cursor
  "Filter by owner address"
  ownerAddress: EthereumAddress!
  "Filter by contract address"
  contractAddress: ContractAddress
  "Chain Ids"
  chainIds: [ChainId!]!
}

input NftOwnershipChallenge {
  "ContractAddress for nft"
  contractAddress: ContractAddress!
  "Token id for NFT"
  tokenId: String!
  "Chain Id"
  chainId: ChainId!
}

input NftOwnershipChallengeRequest {
  "The wallet address which owns the NFT"
  ethereumAddress: EthereumAddress!
  nfts: [NftOwnershipChallenge!]!
}

input NotificationRequest {
  limit: LimitScalar
  cursor: Cursor
  "The profile id"
  profileId: ProfileId!
  "The App Id"
  sources: [Sources!] = []
}

input PendingApprovalFollowsRequest {
  limit: LimitScalar
  cursor: Cursor
}

input ProfileFollowModuleBeenRedeemedRequest {
  followProfileId: ProfileId!
  redeemingProfileId: ProfileId!
}

input ProfileFollowModuleRedeemParams {
  "The profile id to use to follow this profile"
  profileId: ProfileId!
}

input ProfilePublicationsForSaleRequest {
  limit: LimitScalar
  cursor: Cursor
  "Profile id"
  profileId: ProfileId!
  "The App Id"
  sources: [Sources!] = []
}

input ProfileQueryRequest {
  limit: LimitScalar
  cursor: Cursor
  "The profile ids"
  profileIds: [ProfileId!]
  "The ethereum addresses"
  ownedBy: [EthereumAddress!]
  "The handles for the profile"
  handles: [Handle!]
  "The mirrored publication id"
  whoMirroredPublicationId: InternalPublicationId
}

input ProfileRevenueQueryRequest {
  limit: LimitScalar
  cursor: Cursor
  "The profile id"
  profileId: ProfileId!
  "The App Id"
  sources: [Sources!] = []
  "The revenue types"
  types: [ProfileRevenueTypes!] = [COMMENT, MIRROR, POST]
}

input PublicationQueryRequest {
  "The publication id"
  publicationId: InternalPublicationId
  "The tx hash"
  txHash: TxHash
}

input PublicationRevenueQueryRequest {
  "The publication id"
  publicationId: InternalPublicationId!
}

input PublicationsQueryRequest {
  limit: LimitScalar
  cursor: Cursor
  "Profile id"
  profileId: ProfileId
  "The publication types you want to query"
  publicationTypes: [PublicationTypes!]
  "The publication id you wish to get comments for"
  commentsOf: InternalPublicationId
  "The App Id"
  sources: [Sources!] = []
  "The ethereum address"
  collectedBy: EthereumAddress
  "The publication id"
  publicationIds: [InternalPublicationId!]
}

input ReactionFieldResolverRequest {
  "Profile id"
  profileId: ProfileId!
}

input ReactionRequest {
  "Profile id to perform the action"
  profileId: ProfileId!
  "The reaction"
  reaction: ReactionTypes!
  "The internal publication id"
  publicationId: InternalPublicationId!
}

input ReferenceModuleParams {
  "The follower only reference module"
  followerOnlyReferenceModule: Boolean
}

"The refresh request"
input RefreshRequest {
  "The refresh token"
  refreshToken: Jwt!
}

input ReportPublicationRequest {
  publicationId: InternalPublicationId!
  reason: ReportingReasonInputParams!
  additionalComments: String
}

input ReportingReasonInputParams {
  sensitiveReason: SensitiveReasonInputParams
  illegalReason: IllegalReasonInputParams
  fraudReason: FraudReasonInputParams
}

input SearchQueryRequest {
  limit: LimitScalar
  cursor: Cursor
  "The search term"
  query: Search!
  type: SearchRequestTypes!
  "The App Id"
  sources: [Sources!] = []
}

input SensitiveReasonInputParams {
  reason: PublicationReportingReason!
  subreason: PublicationReportingSensitiveSubreason!
}

input SetDispatcherRequest {
  "The profile id"
  profileId: ProfileId!
  "The dispatcher address - they can post, comment, mirror, set follow module, change your profile picture on your behalf."
  dispatcher: EthereumAddress
  "If you want to enable or disable it"
  enable: Boolean
}

"The signed auth challenge"
input SignedAuthChallenge {
  "The ethereum address you signed the signature with"
  address: EthereumAddress!
  "The signature"
  signature: Signature!
}

input SingleProfileQueryRequest {
  "The profile id"
  profileId: ProfileId
  "The handle for the profile"
  handle: Handle
}

input TimedFeeCollectModuleParams {
  "The collect module amount info"
  amount: ModuleFeeAmountParams!
  "The collect module recipient address"
  recipient: EthereumAddress!
  "The collect module referral fee"
  referralFee: Float!
  "Follower only"
  followerOnly: Boolean!
}

input TimelineRequest {
  limit: LimitScalar
  cursor: Cursor
  "The profile id"
  profileId: ProfileId!
  "The App Id"
  sources: [Sources!] = []
  "The timeline types you wish to include, if nothing passed in will bring back all"
  timelineTypes: [TimelineType!] = [COLLECT_COMMENT, COLLECT_POST, COMMENT, POST, MIRROR]
}

input TypedDataOptions {
  "If you wish to override the nonce for the sig if you want to do some clever stuff in the client"
  overrideSigNonce: Nonce!
}

input UnfollowRequest {
  profile: ProfileId!
}

input UpdateProfileImageRequest {
  profileId: ProfileId!
  "The url to the image if offline"
  url: Url
  "The nft data"
  nftData: NFTData
}

"The access request"
input VerifyRequest {
  "The access token"
  accessToken: Jwt!
}

input WhoCollectedPublicationRequest {
  limit: LimitScalar
  cursor: Cursor
  "Internal publication id"
  publicationId: InternalPublicationId!
}

type ApprovedAllowanceAmount {
  currency: ContractAddress!
  module: String!
  contractAddress: ContractAddress!
  allowance: String!
}

"The Profile"
type Attribute {
  "The display type"
  displayType: MetadataDisplayType
  "The trait type - can be anything its the name it will render so include spaces"
  traitType: String
  "identifier of this attribute, we will update by this id "
  key: String!
  "Value attribute"
  value: String!
}

"The auth challenge result"
type AuthChallengeResult {
  "The text to sign"
  text: String!
}

"The authentication result"
type AuthenticationResult {
  "The access token"
  accessToken: Jwt!
  "The refresh token"
  refreshToken: Jwt!
}

type ClaimableHandles {
  reservedHandles: [ReservedClaimableHandle!]!
  canClaimFreeTextHandle: Boolean!
}

"The social comment"
type Comment {
  "The internal publication id"
  id: InternalPublicationId!
  "The profile ref"
  profile: Profile!
  "The publication stats"
  stats: PublicationStats!
  "The metadata for the post"
  metadata: MetadataOutput!
  "The on chain content uri could be `ipfs://` or `https`"
  onChainContentURI: String!
  "The date the post was created on"
  createdAt: DateTime!
  "The collect module"
  collectModule: CollectModule!
  "The reference module"
  referenceModule: ReferenceModule
  "ID of the source"
  appId: Sources
  "If the publication has been hidden if it has then the content and media is not available"
  hidden: Boolean!
  "The contract address for the collect nft.. if its null it means nobody collected yet as it lazy deployed"
  collectNftAddress: ContractAddress
  "The top level post/mirror this comment lives on"
  mainPost: MainPostReference!
  "Which comment this points to if its null the pointer too deep so do another query to find it out"
  commentOn: Publication
  "This will bring back the first comment of a comment and only be defined if using `publication` query and `commentOf`"
  firstComment: Comment
  "Who collected it, this is used for timeline results and like this for better caching for the client"
  collectedBy: Wallet
  reaction(request: ReactionFieldResolverRequest): ReactionTypes
  hasCollectedByMe: Boolean!
  mirrors(by: ProfileId): [InternalPublicationId!]!
}

"The create burn eip 712 typed data"
type CreateBurnEIP712TypedData {
  "The types"
  types: CreateBurnEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateBurnEIP712TypedDataValue!
}

"The create burn eip 712 typed data types"
type CreateBurnEIP712TypedDataTypes {
  BurnWithSig: [EIP712TypedDataField!]!
}

"The create burn eip 712 typed data value"
type CreateBurnEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  tokenId: String!
}

"The broadcast item"
type CreateBurnProfileBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateBurnEIP712TypedData!
}

"The broadcast item"
type CreateCollectBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateCollectEIP712TypedData!
}

"The collect eip 712 typed data"
type CreateCollectEIP712TypedData {
  "The types"
  types: CreateCollectEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateCollectEIP712TypedDataValue!
}

"The collect eip 712 typed data types"
type CreateCollectEIP712TypedDataTypes {
  CollectWithSig: [EIP712TypedDataField!]!
}

"The collect eip 712 typed data value"
type CreateCollectEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  pubId: PublicationId!
  data: BlockchainData!
}

"The broadcast item"
type CreateCommentBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateCommentEIP712TypedData!
}

"The create comment eip 712 typed data"
type CreateCommentEIP712TypedData {
  "The types"
  types: CreateCommentEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateCommentEIP712TypedDataValue!
}

"The create comment eip 712 typed data types"
type CreateCommentEIP712TypedDataTypes {
  CommentWithSig: [EIP712TypedDataField!]!
}

"The create comment eip 712 typed data value"
type CreateCommentEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  contentURI: PublicationUrl!
  profileIdPointed: ProfileId!
  pubIdPointed: PublicationId!
  collectModule: ContractAddress!
  collectModuleInitData: CollectModuleData!
  referenceModule: ContractAddress!
  referenceModuleInitData: ReferenceModuleData!
  referenceModuleData: ReferenceModuleData!
}

"The broadcast item"
type CreateFollowBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateFollowEIP712TypedData!
}

"The create follow eip 712 typed data"
type CreateFollowEIP712TypedData {
  "The types"
  types: CreateFollowEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateFollowEIP712TypedDataValue!
}

"The create follow eip 712 typed data types"
type CreateFollowEIP712TypedDataTypes {
  FollowWithSig: [EIP712TypedDataField!]!
}

"The create follow eip 712 typed data value"
type CreateFollowEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileIds: [ProfileId!]!
  datas: [BlockchainData!]!
}

"The broadcast item"
type CreateMirrorBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateMirrorEIP712TypedData!
}

"The mirror eip 712 typed data"
type CreateMirrorEIP712TypedData {
  "The types"
  types: CreateMirrorEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateMirrorEIP712TypedDataValue!
}

"The mirror eip 712 typed data types"
type CreateMirrorEIP712TypedDataTypes {
  MirrorWithSig: [EIP712TypedDataField!]!
}

"The mirror eip 712 typed data value"
type CreateMirrorEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  profileIdPointed: ProfileId!
  pubIdPointed: PublicationId!
  referenceModuleData: ReferenceModuleData!
  referenceModule: ContractAddress!
  referenceModuleInitData: ReferenceModuleData!
}

"The broadcast item"
type CreatePostBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreatePostEIP712TypedData!
}

"The create post eip 712 typed data"
type CreatePostEIP712TypedData {
  "The types"
  types: CreatePostEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreatePostEIP712TypedDataValue!
}

"The create post eip 712 typed data types"
type CreatePostEIP712TypedDataTypes {
  PostWithSig: [EIP712TypedDataField!]!
}

"The create post eip 712 typed data value"
type CreatePostEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  contentURI: PublicationUrl!
  collectModule: ContractAddress!
  collectModuleInitData: CollectModuleData!
  referenceModule: ContractAddress!
  referenceModuleInitData: ReferenceModuleData!
}

"The broadcast item"
type CreateSetDispatcherBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateSetDispatcherEIP712TypedData!
}

"The set dispatcher eip 712 typed data"
type CreateSetDispatcherEIP712TypedData {
  "The types"
  types: CreateSetDispatcherEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateSetDispatcherEIP712TypedDataValue!
}

"The set dispatcher eip 712 typed data types"
type CreateSetDispatcherEIP712TypedDataTypes {
  SetDispatcherWithSig: [EIP712TypedDataField!]!
}

"The set dispatcher eip 712 typed data value"
type CreateSetDispatcherEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  dispatcher: EthereumAddress!
}

"The broadcast item"
type CreateSetFollowModuleBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateSetFollowModuleEIP712TypedData!
}

"The set follow module eip 712 typed data"
type CreateSetFollowModuleEIP712TypedData {
  "The types"
  types: CreateSetFollowModuleEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateSetFollowModuleEIP712TypedDataValue!
}

"The set follow module eip 712 typed data types"
type CreateSetFollowModuleEIP712TypedDataTypes {
  SetFollowModuleWithSig: [EIP712TypedDataField!]!
}

"The set follow module eip 712 typed data value"
type CreateSetFollowModuleEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  followModule: ContractAddress!
  followModuleInitData: FollowModuleData!
}

"The broadcast item"
type CreateSetFollowNFTUriBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateSetFollowNFTUriEIP712TypedData!
}

"The set follow nft uri eip 712 typed data"
type CreateSetFollowNFTUriEIP712TypedData {
  "The types"
  types: CreateSetFollowNFTUriEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateSetFollowNFTUriEIP712TypedDataValue!
}

"The set follow nft uri eip 712 typed data types"
type CreateSetFollowNFTUriEIP712TypedDataTypes {
  SetFollowNFTURIWithSig: [EIP712TypedDataField!]!
}

"The set follow nft uri eip 712 typed data value"
type CreateSetFollowNFTUriEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  followNFTURI: Url!
}

"The broadcast item"
type CreateSetProfileImageUriBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateSetProfileImageUriEIP712TypedData!
}

"The set profile uri eip 712 typed data"
type CreateSetProfileImageUriEIP712TypedData {
  "The types"
  types: CreateSetProfileImageUriEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateSetProfileImageUriEIP712TypedDataValue!
}

"The set profile image uri eip 712 typed data types"
type CreateSetProfileImageUriEIP712TypedDataTypes {
  SetProfileImageURIWithSig: [EIP712TypedDataField!]!
}

"The set profile uri eip 712 typed data value"
type CreateSetProfileImageUriEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  imageURI: Url!
}

"The broadcast item"
type CreateSetProfileMetadataURIBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateSetProfileMetadataURIEIP712TypedData!
}

"The set follow nft uri eip 712 typed data"
type CreateSetProfileMetadataURIEIP712TypedData {
  "The types"
  types: CreateSetProfileMetadataURIEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateSetProfileMetadataURIEIP712TypedDataValue!
}

"The set follow nft uri eip 712 typed data types"
type CreateSetProfileMetadataURIEIP712TypedDataTypes {
  SetProfileMetadataURIWithSig: [EIP712TypedDataField!]!
}

"The set follow nft uri eip 712 typed data value"
type CreateSetProfileMetadataURIEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  metadata: Url!
}

"The broadcast item"
type CreateToggleFollowBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateToggleFollowEIP712TypedData!
}

"The create toggle follows eip 712 typed data"
type CreateToggleFollowEIP712TypedData {
  "The types"
  types: CreateToggleFollowEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateToggleFollowEIP712TypedDataValue!
}

"The create toggle follows eip 712 typed data types"
type CreateToggleFollowEIP712TypedDataTypes {
  ToggleFollowWithSig: [EIP712TypedDataField!]!
}

"The create toggle follow eip 712 typed data value"
type CreateToggleFollowEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileIds: [ProfileId!]!
  enables: [Boolean!]!
}

"The broadcast item"
type CreateUnfollowBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateBurnEIP712TypedData!
}

"The dispatcher"
type Dispatcher {
  "The dispatcher address"
  address: EthereumAddress!
  "If the dispatcher can use the relay"
  canUseRelay: Boolean!
}

"The does follow response"
type DoesFollowResponse {
  "The follower address remember wallets follow profiles"
  followerAddress: EthereumAddress!
  "The profile id"
  profileId: ProfileId!
  "If the user does follow"
  follows: Boolean!
}

"The eip 712 typed data domain"
type EIP712TypedDataDomain {
  "The name of the typed data domain"
  name: String!
  "The chainId"
  chainId: ChainId!
  "The version"
  version: String!
  "The verifying contract"
  verifyingContract: ContractAddress!
}

"The eip 712 typed data field"
type EIP712TypedDataField {
  "The name of the typed data field"
  name: String!
  "The type of the typed data field"
  type: String!
}

type EnabledModule {
  moduleName: String!
  contractAddress: ContractAddress!
  inputParams: [ModuleInfo!]!
  redeemParams: [ModuleInfo!]!
  returnDataParms: [ModuleInfo!]!
}

"The enabled modules"
type EnabledModules {
  collectModules: [EnabledModule!]!
  followModules: [EnabledModule!]!
  referenceModules: [EnabledModule!]!
}

"The erc20 type"
type Erc20 {
  "Name of the symbol"
  name: String!
  "Symbol for the token"
  symbol: String!
  "Decimal places for the token"
  decimals: Int!
  "The erc20 address"
  address: ContractAddress!
}

type Erc20Amount {
  "The erc20 token info"
  asset: Erc20!
  "Floating point number as string (e.g. 42.009837). It could have the entire precision of the Asset or be truncated to the last significant decimal."
  value: String!
}

"The paginated publication result"
type ExploreProfileResult {
  items: [Profile!]!
  pageInfo: PaginatedResultInfo!
}

"The paginated publication result"
type ExplorePublicationResult {
  items: [Publication!]!
  pageInfo: PaginatedResultInfo!
}

type FeeCollectModuleSettings {
  "The collect modules enum"
  type: CollectModules!
  contractAddress: ContractAddress!
  "The collect module amount info"
  amount: ModuleFeeAmount!
  "The collect module recipient address"
  recipient: EthereumAddress!
  "The collect module referral fee"
  referralFee: Float!
  "Follower only"
  followerOnly: Boolean!
}

type FeeFollowModuleSettings {
  "The follow modules enum"
  type: FollowModules!
  contractAddress: ContractAddress!
  "The collect module amount info"
  amount: ModuleFeeAmount!
  "The collect module recipient address"
  recipient: EthereumAddress!
}

type FollowOnlyReferenceModuleSettings {
  "The reference modules enum"
  type: ReferenceModules!
  contractAddress: ContractAddress!
}

type Follower {
  wallet: Wallet!
  totalAmountOfTimesFollowed: Int!
}

type FollowerNftOwnedTokenIds {
  followerNftAddress: ContractAddress!
  tokensIds: [String!]!
}

type Following {
  profile: Profile!
  totalAmountOfTimesFollowing: Int!
}

type FreeCollectModuleSettings {
  "The collect modules enum"
  type: CollectModules!
  contractAddress: ContractAddress!
  "Follower only"
  followerOnly: Boolean!
}

type GenerateModuleCurrencyApproval {
  to: ContractAddress!
  from: EthereumAddress!
  data: BlockchainData!
}

type GlobalProtocolStats {
  totalProfiles: Int!
  totalBurntProfiles: Int!
  totalPosts: Int!
  totalMirrors: Int!
  totalComments: Int!
  totalCollects: Int!
  totalFollows: Int!
  totalRevenue: [Erc20Amount!]!
}

type HasCollectedItem {
  collected: Boolean!
  collectedTimes: Int!
  publicationId: InternalPublicationId!
}

type HasCollectedResult {
  "Wallet address"
  walletAddress: EthereumAddress!
  results: [HasCollectedItem!]!
}

type HasMirroredItem {
  mirrored: Boolean!
  publicationId: InternalPublicationId!
}

type HasMirroredResult {
  "Profile id"
  profileId: ProfileId!
  results: [HasMirroredItem!]!
}

type LimitedFeeCollectModuleSettings {
  "The collect modules enum"
  type: CollectModules!
  contractAddress: ContractAddress!
  "The collect module limit"
  collectLimit: String!
  "The collect module amount info"
  amount: ModuleFeeAmount!
  "The collect module recipient address"
  recipient: EthereumAddress!
  "The collect module referral fee"
  referralFee: Float!
  "Follower only"
  followerOnly: Boolean!
}

type LimitedTimedFeeCollectModuleSettings {
  "The collect modules enum"
  type: CollectModules!
  contractAddress: ContractAddress!
  "The collect module limit"
  collectLimit: String!
  "The collect module amount info"
  amount: ModuleFeeAmount!
  "The collect module recipient address"
  recipient: EthereumAddress!
  "The collect module referral fee"
  referralFee: Float!
  "Follower only"
  followerOnly: Boolean!
  "The collect module end timestamp"
  endTimestamp: DateTime!
}

type Log {
  blockNumber: Int!
  blockHash: String!
  transactionIndex: Int!
  removed: Boolean!
  address: ContractAddress!
  data: String!
  topics: [String!]!
  transactionHash: TxHash!
  logIndex: Int!
}

"The Media url"
type Media {
  "The token image nft"
  url: Url!
  "Width - will always be null on the public API"
  width: Int
  "Height - will always be null on the public API"
  height: Int
  "Size - will always be null on the public API"
  size: Int
  "The image/audio/video mime type for the publication"
  mimeType: MimeType
}

"The Media Set"
type MediaSet {
  "Original media"
  original: Media!
  "Small media - will always be null on the public API"
  small: Media
  "Medium media - will always be null on the public API"
  medium: Media
}

"The metadata attribute output"
type MetadataAttributeOutput {
  "The display type"
  displayType: MetadataDisplayType
  "The trait type - can be anything its the name it will render so include spaces"
  traitType: String
  "The value"
  value: String
}

"The metadata output"
type MetadataOutput {
  "The metadata name"
  name: String
  "This is the metadata description"
  description: Markdown
  "This is the metadata content for the publication, should be markdown"
  content: Markdown
  "This is the image attached to the metadata and the property used to show the NFT!"
  image: Url
  "The image cover for video/music publications"
  cover: MediaSet
  "The images/audios/videos for the publication"
  media: [MediaSet!]!
  "The attributes"
  attributes: [MetadataAttributeOutput!]!
}

"The social mirror"
type Mirror {
  "The internal publication id"
  id: InternalPublicationId!
  "The profile ref"
  profile: Profile!
  "The publication stats"
  stats: PublicationStats!
  "The metadata for the post"
  metadata: MetadataOutput!
  "The on chain content uri could be `ipfs://` or `https`"
  onChainContentURI: String!
  "The date the post was created on"
  createdAt: DateTime!
  "The collect module"
  collectModule: CollectModule!
  "The reference module"
  referenceModule: ReferenceModule
  "ID of the source"
  appId: Sources
  "If the publication has been hidden if it has then the content and media is not available"
  hidden: Boolean!
  "The contract address for the collect nft.. if its null it means nobody collected yet as it lazy deployed"
  collectNftAddress: ContractAddress
  "The mirror publication"
  mirrorOf: MirrorablePublication!
  reaction(request: ReactionFieldResolverRequest): ReactionTypes
  hasCollectedByMe: Boolean!
}

type ModuleFeeAmount {
  "The erc20 token info"
  asset: Erc20!
  "Floating point number as string (e.g. 42.009837). It could have the entire precision of the Asset or be truncated to the last significant decimal."
  value: String!
}

type ModuleInfo {
  name: String!
  type: String!
}

type Mutation {
  authenticate(request: SignedAuthChallenge!): AuthenticationResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  refresh(request: RefreshRequest!): AuthenticationResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  broadcast(request: BroadcastRequest!): RelayResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  createSetDispatcherTypedData(options: TypedDataOptions, request: SetDispatcherRequest!): CreateSetDispatcherBroadcastItemResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  createFollowTypedData(options: TypedDataOptions, request: FollowRequest!): CreateFollowBroadcastItemResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  createUnfollowTypedData(options: TypedDataOptions, request: UnfollowRequest!): CreateUnfollowBroadcastItemResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  createSetFollowModuleTypedData(options: TypedDataOptions, request: CreateSetFollowModuleRequest!): CreateSetFollowModuleBroadcastItemResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  createSetFollowNFTUriTypedData(options: TypedDataOptions, request: CreateSetFollowNFTUriRequest!): CreateSetFollowNFTUriBroadcastItemResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  createToggleFollowTypedData(options: TypedDataOptions, request: CreateToggleFollowRequest!): CreateToggleFollowBroadcastItemResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  createCollectTypedData(options: TypedDataOptions, request: CreateCollectRequest!): CreateCollectBroadcastItemResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  createSetDefaultProfileTypedData(options: TypedDataOptions, request: CreateSetDefaultProfileRequest!): SetDefaultProfileBroadcastItemResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  createSetProfileImageURITypedData(options: TypedDataOptions, request: UpdateProfileImageRequest!): CreateSetProfileImageUriBroadcastItemResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  createBurnProfileTypedData(options: TypedDataOptions, request: BurnProfileRequest!): CreateBurnProfileBroadcastItemResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  createPostTypedData(options: TypedDataOptions, request: CreatePublicPostRequest!): CreatePostBroadcastItemResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  createCommentTypedData(options: TypedDataOptions, request: CreatePublicCommentRequest!): CreateCommentBroadcastItemResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  createMirrorTypedData(options: TypedDataOptions, request: CreateMirrorRequest!): CreateMirrorBroadcastItemResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  hidePublication(request: HidePublicationRequest!): Void @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  claim(request: ClaimHandleRequest!): RelayResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  createProfile(request: CreateProfileRequest!): RelayResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  createSetProfileMetadataTypedData(options: TypedDataOptions, request: CreatePublicSetProfileMetadataURIRequest!): CreateSetProfileMetadataURIBroadcastItemResult!
    @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  addReaction(request: ReactionRequest!): Void @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  removeReaction(request: ReactionRequest!): Void @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  reportPublication(request: ReportPublicationRequest!): Void @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  ach(request: AchRequest!): Void @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
}

"The nft type"
type NFT {
  "aka us CryptoKitties"
  contractName: String!
  "aka 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e "
  contractAddress: ContractAddress!
  "aka RARI"
  symbol: String!
  "aka \"13\" "
  tokenId: String!
  "aka { address: 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e, amount:\"2\" } "
  owners: [Owner!]!
  "aka \"Beard Coffee\" "
  name: String!
  "aka \"Hey cutie! I m Beard Coffee. .... "
  description: String!
  "aka \"https://api.criptokitt...\" "
  contentURI: String!
  "aka \"{ uri:\"https://ipfs....\", metaType:\"image/png\" }\" "
  originalContent: NFTContent!
  "aka \"1\" "
  chainId: ChainId!
  "aka \"CryptoKitties\" "
  collectionName: String!
  "aka \"ERC721\" "
  ercType: String!
}

"The NFT content uri"
type NFTContent {
  "The token uri  nft"
  uri: String!
  "The meta type content"
  metaType: String!
  "The animated url"
  animatedUrl: String
}

"Paginated nft results"
type NFTsResult {
  items: [NFT!]!
  pageInfo: PaginatedResultInfo!
}

type NewCollectNotification {
  wallet: Wallet!
  collectedPublication: Publication!
  createdAt: DateTime!
}

type NewCommentNotification {
  "The profile"
  profile: Profile!
  comment: Comment!
  createdAt: DateTime!
}

type NewFollowerNotification {
  wallet: Wallet!
  isFollowedByMe: Boolean!
  createdAt: DateTime!
}

type NewMentionNotification {
  mentionPublication: MentionPublication!
  createdAt: DateTime!
}

type NewMirrorNotification {
  "The profile"
  profile: Profile!
  publication: MirrorablePublication!
  createdAt: DateTime!
}

"The NFT image"
type NftImage {
  "The contract address"
  contractAddress: ContractAddress!
  "The token id of the nft"
  tokenId: String!
  "The token image nft"
  uri: Url!
  "The token image nft"
  chainId: Int!
  "If the NFT is verified"
  verified: Boolean!
}

"NFT ownership challenge result"
type NftOwnershipChallengeResult {
  "Id of the nft ownership challenge"
  id: NftOwnershipId!
  text: String!
  "Timeout of the validation"
  timeout: TimestampScalar!
}

"The nft type"
type Owner {
  "number of tokens owner"
  amount: Float!
  "aka 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e "
  address: EthereumAddress!
}

"The paginated followers result"
type PaginatedFollowersResult {
  items: [Follower!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedFollowingResult {
  items: [Following!]!
  pageInfo: PaginatedResultInfo!
}

"The paginated notification result"
type PaginatedNotificationResult {
  items: [Notification!]!
  pageInfo: PaginatedResultInfo!
}

"The paginated wallet result"
type PaginatedProfilePublicationsForSaleResult {
  items: [PublicationForSale!]!
  pageInfo: PaginatedResultInfo!
}

"The paginated profile result"
type PaginatedProfileResult {
  items: [Profile!]!
  pageInfo: PaginatedResultInfo!
}

"The paginated publication result"
type PaginatedPublicationResult {
  items: [Publication!]!
  pageInfo: PaginatedResultInfo!
}

"The paginated result info"
type PaginatedResultInfo {
  "Cursor to query the actual results"
  prev: Cursor
  "Cursor to query next results"
  next: Cursor
  "The total number of entities the pagination iterates over. e.g. For a query that requests all nfts with more than 10 likes, this field gives the total amount of nfts with more than 10 likes, not the total amount of nfts"
  totalCount: Int!
}

"The paginated timeline result"
type PaginatedTimelineResult {
  items: [Publication!]!
  pageInfo: PaginatedResultInfo!
}

"The paginated wallet result"
type PaginatedWhoCollectedResult {
  items: [Wallet!]!
  pageInfo: PaginatedResultInfo!
}

"The paginated follow result"
type PendingApproveFollowsResult {
  items: [Profile!]!
  pageInfo: PaginatedResultInfo!
}

"The social post"
type Post {
  "The internal publication id"
  id: InternalPublicationId!
  "The profile ref"
  profile: Profile!
  "The publication stats"
  stats: PublicationStats!
  "The metadata for the post"
  metadata: MetadataOutput!
  "The on chain content uri could be `ipfs://` or `https`"
  onChainContentURI: String!
  "The date the post was created on"
  createdAt: DateTime!
  "The collect module"
  collectModule: CollectModule!
  "The reference module"
  referenceModule: ReferenceModule
  "ID of the source"
  appId: Sources
  "If the publication has been hidden if it has then the content and media is not available"
  hidden: Boolean!
  "The contract address for the collect nft.. if its null it means nobody collected yet as it lazy deployed"
  collectNftAddress: ContractAddress
  "Who collected it, this is used for timeline results and like this for better caching for the client"
  collectedBy: Wallet
  reaction(request: ReactionFieldResolverRequest): ReactionTypes
  hasCollectedByMe: Boolean!
  mirrors(by: ProfileId): [InternalPublicationId!]!
}

"The Profile"
type Profile {
  "The profile id"
  id: ProfileId!
  "Name of the profile"
  name: String
  "Bio of the profile"
  bio: String
  "Follow nft address"
  followNftAddress: ContractAddress
  "Metadata url"
  metadata: Url
  "The profile handle"
  handle: Handle!
  "The picture for the profile"
  picture: ProfileMedia
  "The cover picture for the profile"
  coverPicture: ProfileMedia
  "Who owns the profile"
  ownedBy: EthereumAddress!
  "The dispatcher"
  dispatcher: Dispatcher
  "Profile stats"
  stats: ProfileStats!
  "The follow module"
  followModule: FollowModule
  "Is the profile default"
  isDefault: Boolean!
  "Optionals param to add extra attributes on the metadata"
  attributes: [Attribute!]
  isFollowedByMe: Boolean!
  isFollowing(who: ProfileId): Boolean!
}

type ProfileFollowModuleSettings {
  "The follow module enum"
  type: FollowModules!
  contractAddress: ContractAddress!
}

"The paginated revenue result"
type ProfileRevenueResult {
  items: [PublicationRevenue!]!
  pageInfo: PaginatedResultInfo!
}

"Profile search results"
type ProfileSearchResult {
  items: [Profile!]!
  pageInfo: PaginatedResultInfo!
  type: SearchRequestTypes!
}

"The Profile Stats"
type ProfileStats {
  "Total follower count"
  totalFollowers: Int!
  "Total following count (remember the wallet follows not profile so will be same for every profile they own)"
  totalFollowing: Int!
  "Total post count"
  totalPosts: Int!
  "Total comment count"
  totalComments: Int!
  "Total mirror count"
  totalMirrors: Int!
  "Total publication count"
  totalPublications: Int!
  "Total collects count"
  totalCollects: Int!
}

type PublicationMetadataStatus {
  status: PublicationMetadataStatusType!
  "If metadata validation failed it will put a reason why here"
  reason: String
}

"The social comment"
type PublicationRevenue {
  publication: Publication!
  earnings: Erc20Amount!
  "Protocol treasury fee %"
  protocolFee: Float!
}

"Publication search results"
type PublicationSearchResult {
  items: [PublicationSearchResultItem!]!
  pageInfo: PaginatedResultInfo!
  type: SearchRequestTypes!
}

"The publication stats"
type PublicationStats {
  "The total amount of mirrors"
  totalAmountOfMirrors: Int!
  "The total amount of collects"
  totalAmountOfCollects: Int!
  "The total amount of comments"
  totalAmountOfComments: Int!
  "The total amount of downvotes"
  totalUpvotes: Int!
  "The total amount of upvotes"
  totalDownvotes: Int!
}

type Query {
  challenge(request: ChallengeRequest!): AuthChallengeResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  verify(request: VerifyRequest!): Boolean! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  explorePublications(request: ExplorePublicationRequest!): ExplorePublicationResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  exploreProfiles(request: ExploreProfilesRequest!): ExploreProfileResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  pendingApprovalFollows(request: PendingApprovalFollowsRequest!): PendingApproveFollowsResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  doesFollow(request: DoesFollowRequest!): [DoesFollowResponse!]! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  following(request: FollowingRequest!): PaginatedFollowingResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  followers(request: FollowersRequest!): PaginatedFollowersResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  followerNftOwnedTokenIds(request: FollowerNftOwnedTokenIdsRequest!): FollowerNftOwnedTokenIds! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  ping: String! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  hasTxHashBeenIndexed(request: HasTxHashBeenIndexedRequest!): TransactionResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  enabledModuleCurrencies: [Erc20!]! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  approvedModuleAllowanceAmount(request: ApprovedModuleAllowanceAmountRequest!): [ApprovedAllowanceAmount!]! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  generateModuleCurrencyApprovalData(request: GenerateModuleCurrencyApprovalDataRequest!): GenerateModuleCurrencyApproval! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  profileFollowModuleBeenRedeemed(request: ProfileFollowModuleBeenRedeemedRequest!): Boolean! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  enabledModules: EnabledModules! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  nfts(request: NFTsRequest!): NFTsResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  nftOwnershipChallenge(request: NftOwnershipChallengeRequest!): NftOwnershipChallengeResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  notifications(request: NotificationRequest!): PaginatedNotificationResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  profiles(request: ProfileQueryRequest!): PaginatedProfileResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  profile(request: SingleProfileQueryRequest!): Profile @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  recommendedProfiles: [Profile!]! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  defaultProfile(request: DefaultProfileRequest!): Profile @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  globalProtocolStats(request: GlobalProtocolStatsRequest): GlobalProtocolStats! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  publications(request: PublicationsQueryRequest!): PaginatedPublicationResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  publication(request: PublicationQueryRequest!): Publication @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  hasMirrored(request: HasMirroredRequest!): [HasMirroredResult!]!
    @deprecated(reason: "you should use the `mirrors` field resolver passing in the profile id the user is active on, this lives on the publication, this will be removed from on 1st of July 2022")
    @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  hasCollected(request: HasCollectedRequest!): [HasCollectedResult!]!
    @deprecated(reason: "you should use the `hasCollectedByMe` field resolver on the publication, this will be removed from on 1st of July 2022")
    @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  whoCollectedPublication(request: WhoCollectedPublicationRequest!): PaginatedWhoCollectedResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  profilePublicationsForSale(request: ProfilePublicationsForSaleRequest!): PaginatedProfilePublicationsForSaleResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  search(request: SearchQueryRequest!): SearchResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  timeline(request: TimelineRequest!): PaginatedTimelineResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  userSigNonces: UserSigNonces! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  claimableHandles: ClaimableHandles! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  profileRevenue(request: ProfileRevenueQueryRequest!): ProfileRevenueResult! @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
  publicationRevenue(request: PublicationRevenueQueryRequest!): PublicationRevenue @graphql(endpoint: "https://api-mumbai.lens.dev/", forwardheaders: ["x-access-token"], prefix: { includeRootOperations: true, value: "" })
}

type RelayError {
  reason: RelayErrorReasons!
}

"The relayer result"
type RelayerResult {
  "The tx hash - you should use the `txId` as your identifier as gas prices can be upgraded meaning txHash will change"
  txHash: TxHash!
  "The tx id"
  txId: TxId!
}

type ReservedClaimableHandle {
  id: HandleClaimIdScalar!
  handle: Handle!
  source: String!
  expiry: DateTime!
}

type RevertCollectModuleSettings {
  "The collect modules enum"
  type: CollectModules!
  contractAddress: ContractAddress!
}

type RevertFollowModuleSettings {
  "The follow module enum"
  type: FollowModules!
  contractAddress: ContractAddress!
}

"The broadcast item"
type SetDefaultProfileBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: SetDefaultProfileEIP712TypedData!
}

"The default profile eip 712 typed data"
type SetDefaultProfileEIP712TypedData {
  "The types"
  types: SetDefaultProfileEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: SetDefaultProfileEIP712TypedDataValue!
}

"The default profile eip 712 typed data types"
type SetDefaultProfileEIP712TypedDataTypes {
  SetDefaultProfileWithSig: [EIP712TypedDataField!]!
}

"The default profile eip 712 typed data value"
type SetDefaultProfileEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  wallet: EthereumAddress!
  profileId: ProfileId!
}

type TimedFeeCollectModuleSettings {
  "The collect modules enum"
  type: CollectModules!
  contractAddress: ContractAddress!
  "The collect module amount info"
  amount: ModuleFeeAmount!
  "The collect module recipient address"
  recipient: EthereumAddress!
  "The collect module referral fee"
  referralFee: Float!
  "Follower only"
  followerOnly: Boolean!
  "The collect module end timestamp"
  endTimestamp: DateTime!
}

type TransactionError {
  reason: TransactionErrorReasons!
  txReceipt: TransactionReceipt
}

type TransactionIndexedResult {
  indexed: Boolean!
  txHash: TxHash!
  txReceipt: TransactionReceipt
  "Publications can be indexed but the ipfs link for example not findable for x time. This allows you to work that out for publications. If its not a publication tx then it always be null."
  metadataStatus: PublicationMetadataStatus
}

type TransactionReceipt {
  to: EthereumAddress
  from: EthereumAddress!
  contractAddress: ContractAddress
  transactionIndex: Int!
  root: String
  gasUsed: String!
  logsBloom: String!
  blockHash: String!
  transactionHash: TxHash!
  logs: [Log!]!
  blockNumber: Int!
  confirmations: Int!
  cumulativeGasUsed: String!
  effectiveGasPrice: String!
  byzantium: Boolean!
  type: Int!
  status: Int
}

type UserSigNonces {
  lensHubOnChainSigNonce: Nonce!
  peripheryOnChainSigNonce: Nonce!
}

type Wallet {
  address: EthereumAddress!
  "The default profile for the wallet for now it is just their first profile, this will be the default profile they picked soon enough"
  defaultProfile: Profile
}
